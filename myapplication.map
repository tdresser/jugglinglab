alternatives.Color -> a.a:
    alternatives.Color white -> a
    alternatives.Color gray -> b
    alternatives.Color black -> c
    alternatives.Color red -> d
    alternatives.Color pink -> e
    alternatives.Color orange -> f
    alternatives.Color yellow -> g
    alternatives.Color green -> h
    alternatives.Color magenta -> i
    alternatives.Color cyan -> j
    alternatives.Color blue -> k
    void <init>(int,int,int) -> <init>
    void <init>(int,int,int,int) -> <init>
    void <clinit>() -> <clinit>
jugglinglab.JugglingLab -> jugglinglab.JugglingLab:
    void <init>() -> <init>
    void main(java.lang.String[]) -> main
jugglinglab.curve.Curve -> jugglinglab.a.a:
    int numpoints -> a
    double[] times -> b
    jugglinglab.util.Coordinate[] positions -> c
    jugglinglab.util.Coordinate[] velocities -> d
    void <init>() -> <init>
    void calcCurve() -> a
    void getCoordinate(double,jugglinglab.util.Coordinate) -> a
    jugglinglab.util.Coordinate getMax2(double,double) -> a
    jugglinglab.util.Coordinate getMin2(double,double) -> b
    void setCurve(double[],jugglinglab.util.Coordinate[],jugglinglab.util.Coordinate[]) -> a
    double getStartTime() -> b
    double getEndTime() -> c
    jugglinglab.util.Coordinate getMax(double,double) -> c
    jugglinglab.util.Coordinate getMin(double,double) -> d
    jugglinglab.util.Coordinate check(jugglinglab.util.Coordinate,double,boolean) -> a
jugglinglab.curve.SplineCurve -> jugglinglab.a.b:
    int n -> e
    double[][] a -> f
    double[][] b -> g
    double[][] c -> h
    double[][] d -> i
    void <init>() -> <init>
    void calcCurve() -> a
    void findvels_edges_unknown(int,double[],jugglinglab.util.Coordinate[],jugglinglab.util.Coordinate[]) -> a
    void tridag(double[],double[],double[],double[],double[],int) -> a
    void getCoordinate(double,jugglinglab.util.Coordinate) -> a
    jugglinglab.util.Coordinate getMax2(double,double) -> a
    jugglinglab.util.Coordinate getMin2(double,double) -> b
jugglinglab.jml.HandLink -> jugglinglab.b.a:
    jugglinglab.jml.JMLEvent startevent -> a
    jugglinglab.jml.JMLEvent endevent -> b
    jugglinglab.jml.VelocityRef startvelref -> c
    jugglinglab.jml.VelocityRef endvelref -> d
    jugglinglab.curve.Curve hp -> e
    void <init>(int,int,jugglinglab.jml.JMLEvent,jugglinglab.jml.JMLEvent) -> <init>
    int index(int) -> a
    jugglinglab.jml.JMLEvent getStartEvent() -> a
    jugglinglab.jml.JMLEvent getEndEvent() -> b
    jugglinglab.jml.VelocityRef getStartVelocityRef() -> c
    void setStartVelocityRef(jugglinglab.jml.VelocityRef) -> a
    jugglinglab.jml.VelocityRef getEndVelocityRef() -> d
    void setEndVelocityRef(jugglinglab.jml.VelocityRef) -> b
    void setHandCurve(jugglinglab.curve.Curve) -> a
    jugglinglab.curve.Curve getHandCurve() -> e
    java.lang.String toString() -> toString
jugglinglab.jml.JMLDefs -> jugglinglab.b.b:
    java.lang.String[] jmlprefix -> a
    java.lang.String[] jmlsuffix -> b
    void <clinit>() -> <clinit>
jugglinglab.jml.JMLEvent -> jugglinglab.b.c:
    double x -> d
    double y -> e
    double z -> f
    double gx -> g
    double gy -> h
    double gz -> i
    boolean globalvalid -> j
    double t -> k
    int juggler -> l
    int hand -> m
    java.util.ArrayList transitions -> n
    int delay -> a
    int delayunits -> b
    jugglinglab.jml.JMLEvent master -> o
    boolean calcpos -> c
    jugglinglab.jml.JMLEvent prev -> p
    jugglinglab.jml.JMLEvent next -> q
    void <init>() -> <init>
    jugglinglab.util.Coordinate getLocalCoordinate() -> a
    void setLocalCoordinate(jugglinglab.util.Coordinate) -> a
    jugglinglab.util.Coordinate getGlobalCoordinate() -> b
    void setGlobalCoordinate(jugglinglab.util.Coordinate) -> b
    double getT() -> c
    void setT(double) -> a
    int getHand() -> d
    void setHand(int,int) -> a
    int getJuggler() -> e
    int getNumberOfTransitions() -> f
    jugglinglab.jml.JMLTransition getTransition(int) -> a
    void addTransition(jugglinglab.jml.JMLTransition) -> a
    boolean isMaster() -> g
    jugglinglab.jml.JMLEvent getMaster() -> h
    void setMaster(jugglinglab.jml.JMLEvent) -> a
    jugglinglab.jml.JMLEvent getPrevious() -> i
    void setPrevious(jugglinglab.jml.JMLEvent) -> b
    jugglinglab.jml.JMLEvent getNext() -> j
    void setNext(jugglinglab.jml.JMLEvent) -> c
    boolean isDelayOf(jugglinglab.jml.JMLEvent) -> d
    jugglinglab.jml.JMLTransition getPathTransition(int,int) -> b
    jugglinglab.jml.JMLEvent duplicate(int,int) -> c
    void writeJML(java.io.PrintWriter) -> a
    java.lang.String toString() -> toString
jugglinglab.jml.JMLNode -> jugglinglab.b.d:
    jugglinglab.jml.JMLPattern pat -> a
    int numjugglers -> b
    int numpaths -> c
    double looptime -> d
    jugglinglab.util.Permutation loopperm -> e
    jugglinglab.jml.JMLEvent ev -> f
    int evjuggler -> g
    int evhand -> h
    int evtransitions -> i
    double evtime -> j
    jugglinglab.util.Permutation[][][] ea -> k
    int numentries -> l
    int[] transitiontype -> m
    int currentloop -> n
    int currentj -> o
    int currenth -> p
    int currententry -> q
    java.lang.String xmlescape(java.lang.String) -> a
    void <init>(jugglinglab.jml.JMLPattern,jugglinglab.jml.JMLEvent) -> <init>
    jugglinglab.jml.JMLEvent getNext() -> a
    jugglinglab.jml.JMLEvent getPrevious() -> b
    jugglinglab.jml.JMLEvent makeEvent() -> c
    void resetPosition() -> d
    boolean hasJMLTransitionForHand(int,int) -> a
    boolean hasVDJMLTransitionForHand(int,int) -> b
    boolean hasJMLTransitionForPath(int) -> a
    boolean hasVDJMLTransitionForPath(int) -> b
    void calcarray() -> e
jugglinglab.jml.JMLPattern -> jugglinglab.b.e:
    java.lang.String version -> a
    java.lang.String title -> b
    java.lang.String info -> c
    java.util.ArrayList tags -> d
    int numjugglers -> e
    int numpaths -> f
    java.util.ArrayList props -> g
    int[] propassignment -> h
    java.lang.String base_pattern_notation -> i
    java.lang.String base_pattern_config -> j
    boolean[] hasVDPathJMLTransition -> k
    boolean[][] hasVDHandJMLTransition -> l
    java.util.ArrayList symmetries -> m
    jugglinglab.jml.JMLEvent eventlist -> n
    jugglinglab.jml.JMLPosition positionlist -> o
    java.util.ArrayList pathlinks -> p
    java.util.ArrayList handlinks -> q
    jugglinglab.curve.Curve[] jugglercurve -> r
    jugglinglab.curve.Curve[] jugglerangle -> s
    boolean laidout -> t
    boolean valid -> u
    void <init>() -> <init>
    void setTitle(java.lang.String) -> a
    void setNumberOfJugglers(int) -> a
    void setNumberOfPaths(int) -> b
    void addProp(jugglinglab.jml.PropDef) -> a
    void setPropAssignments(int[]) -> a
    void addSymmetry(jugglinglab.jml.JMLSymmetry) -> a
    void addEvent(jugglinglab.jml.JMLEvent) -> a
    void removeEvent(jugglinglab.jml.JMLEvent) -> b
    jugglinglab.jml.JMLEvent getEventList() -> a
    void addPosition(jugglinglab.jml.JMLPosition) -> a
    jugglinglab.jml.JMLPattern fromBasePattern(java.lang.String,java.lang.String) -> a
    double scaleTimeToFitThrows(double) -> a
    jugglinglab.jml.JMLPattern layoutPattern() -> b
    void buildEventList() -> c
    void layoutHandPaths() -> h
    int getNumberOfJugglers() -> d
    int getNumberOfPaths() -> e
    int getPropAssignment(int) -> d
    int getNumberOfSymmetries() -> f
    jugglinglab.jml.JMLSymmetry getSymmetry(int) -> c
    double getLoopEndTime() -> g
    void getHandCoordinate(int,int,double,jugglinglab.util.Coordinate) -> a
    void writeJML(java.io.Writer,boolean,boolean) -> a
    java.lang.String toString() -> toString
jugglinglab.jml.JMLPosition -> jugglinglab.b.f:
    double x -> a
    double y -> b
    double z -> c
    double t -> d
    double angle -> e
    int juggler -> f
    jugglinglab.jml.JMLPosition prev -> g
    jugglinglab.jml.JMLPosition next -> h
    void <init>() -> <init>
    jugglinglab.util.Coordinate getCoordinate() -> a
    void setCoordinate(jugglinglab.util.Coordinate) -> a
    double getAngle() -> b
    void setAngle(double) -> a
    double getT() -> c
    void setT(double) -> b
    int getJuggler() -> d
    void setJuggler(int) -> a
    jugglinglab.jml.JMLPosition getPrevious() -> e
    void setPrevious(jugglinglab.jml.JMLPosition) -> a
    jugglinglab.jml.JMLPosition getNext() -> f
    void setNext(jugglinglab.jml.JMLPosition) -> b
    void writeJML(java.io.PrintWriter) -> a
jugglinglab.jml.JMLSymmetry -> jugglinglab.b.g:
    int type -> a
    int numjugglers -> e
    int numpaths -> f
    jugglinglab.util.Permutation jugglerperm -> b
    jugglinglab.util.Permutation pathperm -> c
    double delay -> d
    void <init>() -> <init>
    void <init>(int,int,java.lang.String,int,java.lang.String,double) -> <init>
    jugglinglab.util.Permutation getPathPerm() -> a
    void writeJML(java.io.PrintWriter) -> a
jugglinglab.jml.JMLTransition -> jugglinglab.b.h:
    int path -> a
    java.lang.String type -> b
    java.lang.String mod -> c
    jugglinglab.jml.PathLink ipl -> d
    jugglinglab.jml.PathLink opl -> e
    int transitiontype -> f
    void <init>(int,int,java.lang.String,java.lang.String) -> <init>
    int getType() -> a
    int getPath() -> b
    void setPath(int) -> a
    java.lang.String getThrowType() -> c
    java.lang.String getMod() -> d
    void setIncomingPathLink(jugglinglab.jml.PathLink) -> a
    jugglinglab.jml.PathLink getIncomingPathLink() -> e
    void setOutgoingPathLink(jugglinglab.jml.PathLink) -> b
    jugglinglab.jml.PathLink getOutgoingPathLink() -> f
    jugglinglab.jml.JMLTransition duplicate() -> g
    void writeJML(java.io.PrintWriter) -> a
jugglinglab.jml.PathLink -> jugglinglab.b.i:
    jugglinglab.jml.JMLEvent startevent -> a
    jugglinglab.jml.JMLEvent endevent -> b
    java.lang.String throwtype -> c
    java.lang.String mod -> d
    jugglinglab.path.Path proppath -> e
    boolean inhand -> f
    void <init>(int,jugglinglab.jml.JMLEvent,jugglinglab.jml.JMLEvent) -> <init>
    void setThrow(java.lang.String,java.lang.String) -> a
    void setInHand(int,int) -> a
    jugglinglab.path.Path getPath() -> a
    java.lang.String toString() -> toString
jugglinglab.jml.PropDef -> jugglinglab.b.j:
    java.lang.String proptype -> a
    java.lang.String mod -> b
    jugglinglab.prop.Prop prop -> c
    void <init>() -> <init>
    void <init>(java.lang.String,java.lang.String) -> <init>
    void writeJML(java.io.PrintWriter) -> a
jugglinglab.jml.VelocityRef -> jugglinglab.b.k:
    int VR_THROW -> a
    int VR_CATCH -> b
    int VR_SOFTCATCH -> c
    jugglinglab.path.Path pp -> d
    int src -> e
    void <init>(jugglinglab.path.Path,int) -> <init>
    jugglinglab.util.Coordinate getVelocity() -> a
    int getSource() -> b
    void <clinit>() -> <clinit>
jugglinglab.notation.MHNBody -> jugglinglab.c.a:
    int jugglers -> a
    int[] size -> b
    int[][] coords -> c
    double[][][][] bodypath -> d
    void <init>(java.lang.String) -> <init>
    int getNumberOfJugglers() -> a
    int getPeriod(int) -> a
    int getNumberOfPositions(int,int) -> a
    jugglinglab.jml.JMLPosition getPosition(int,int,int) -> a
jugglinglab.notation.MHNHands -> jugglinglab.c.b:
    int jugglers -> a
    int[] size -> b
    int[][] coords -> c
    int[][] catches -> d
    double[][][][] handpath -> e
    void <init>(java.lang.String) -> <init>
    int getPeriod(int) -> a
    int getNumberOfCoordinates(int,int) -> a
    int getCatchIndex(int,int) -> b
    jugglinglab.util.Coordinate getCoordinate(int,int,int) -> a
jugglinglab.notation.MHNPattern -> jugglinglab.c.c:
    double bps_default -> l
    double dwell_default -> m
    double gravity_default -> n
    double propdiam_default -> o
    double bouncefrac_default -> p
    double squeezebeats_default -> q
    java.lang.String prop_default -> r
    boolean hold_default -> s
    boolean dwellmax_default -> t
    java.lang.String config -> u
    java.lang.String pattern -> a
    double bps_set -> v
    double dwell -> w
    double gravity -> x
    double propdiam -> y
    double bouncefrac -> z
    double squeezebeats -> A
    java.lang.String prop -> B
    java.lang.String[] color -> C
    java.lang.String title -> D
    java.lang.String hss -> E
    double[] dwellarray -> F
    int numjugglers -> b
    int numpaths -> c
    int period -> d
    int max_occupancy -> e
    jugglinglab.notation.MHNThrow[][][][] th -> f
    jugglinglab.notation.MHNHands hands -> g
    jugglinglab.notation.MHNBody bodies -> h
    int max_throw -> i
    int indexes -> j
    java.util.ArrayList symmetry -> k
    double bps -> G
    double[] samethrowx -> H
    double[] crossingthrowx -> I
    double[] catchx -> J
    double BEATS_ONE_THROW_EARLY -> K
    double BEATS_AIRTIME_MIN -> L
    double BEATS_THROW_CATCH_MIN -> M
    double BEATS_CATCH_THROW_MIN -> N
    double SECS_EVENT_GAP_MAX -> O
    double[] throwspersec -> P
    void <init>() -> <init>
    int getNumberOfJugglers() -> a
    int getPeriod() -> b
    void addSymmetry(jugglinglab.notation.MHNSymmetry) -> a
    jugglinglab.notation.MHNSymmetry getSymmetry(int) -> a
    jugglinglab.notation.MHNPattern fromParameters(jugglinglab.util.ParameterList) -> a
    java.lang.String toString() -> toString
    void buildJugglingMatrix() -> c
    boolean isCatchOrderIncorrect(jugglinglab.notation.MHNThrow,jugglinglab.notation.MHNThrow) -> a
    jugglinglab.jml.JMLPattern asJMLPattern() -> d
    void addEventsForGapsToJML(jugglinglab.jml.JMLPattern) -> a
    void addLocationsForIncompleteEventsToJML(jugglinglab.jml.JMLPattern) -> b
    void addMissingHoldsToJML(jugglinglab.jml.JMLPattern) -> c
    void <clinit>() -> <clinit>
jugglinglab.notation.MHNSymmetry -> jugglinglab.c.d:
    int type -> a
    int numjugglers -> b
    jugglinglab.util.Permutation jugglerperm -> c
    int delay -> d
    void <init>(int,int,java.lang.String,int) -> <init>
jugglinglab.notation.MHNThrow -> jugglinglab.c.e:
    int juggler -> a
    int hand -> b
    int index -> c
    int slot -> d
    int targetjuggler -> e
    int targethand -> f
    int targetindex -> g
    int targetslot -> h
    java.lang.String mod -> i
    jugglinglab.notation.MHNThrow master -> j
    jugglinglab.notation.MHNThrow source -> k
    int pathnum -> l
    boolean catching -> m
    int catchnum -> n
    int dwellwindow -> o
    double throwtime -> p
    double catchtime -> q
    int handsindex -> r
    void <init>() -> <init>
    void <init>(int,int,int,int,int,int,int,int,java.lang.String) -> <init>
    java.lang.String toString() -> toString
    boolean isZero() -> a
    int throwValue() -> c
    boolean isThrownOne() -> b
jugglinglab.notation.Pattern -> jugglinglab.c.f:
    void <init>() -> <init>
    jugglinglab.notation.Pattern newPattern(java.lang.String) -> a
    java.lang.String getNotationName() -> e
    jugglinglab.notation.Pattern fromString(java.lang.String) -> b
    java.lang.String toString() -> toString
    jugglinglab.jml.JMLPattern asJMLPattern() -> d
    void <clinit>() -> <clinit>
jugglinglab.notation.SiteswapPattern -> jugglinglab.c.g:
    boolean oddperiod -> l
    boolean[] right_on_even -> m
    void <init>() -> <init>
    java.lang.String getNotationName() -> e
    jugglinglab.notation.SiteswapPattern fromParameters(jugglinglab.util.ParameterList) -> b
    int getNorepPeriod() -> f
    void parseSiteswapNotation() -> g
    void doFirstPass(jugglinglab.notation.ssparser.SiteswapTreeItem) -> a
    void doSecondPass(jugglinglab.notation.ssparser.SiteswapTreeItem,boolean,int) -> a
    void resolveModifiers() -> h
    jugglinglab.notation.MHNPattern fromParameters(jugglinglab.util.ParameterList) -> a
    jugglinglab.notation.Pattern fromString(java.lang.String) -> b
jugglinglab.notation.ssparser.ParseException -> jugglinglab.c.a.a:
    jugglinglab.notation.ssparser.Token currentToken -> a
    void <init>(jugglinglab.notation.ssparser.Token,int[][],java.lang.String[]) -> <init>
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    java.lang.String initialise(jugglinglab.notation.ssparser.Token,int[][],java.lang.String[]) -> a
    java.lang.String add_escapes(java.lang.String) -> a
jugglinglab.notation.ssparser.SimpleCharStream -> jugglinglab.c.a.b:
    int bufsize -> a
    int available -> b
    int tokenBegin -> c
    int bufpos -> d
    int[] bufline -> e
    int[] bufcolumn -> f
    int column -> g
    int line -> h
    boolean prevCharIsCR -> i
    boolean prevCharIsLF -> j
    java.io.Reader inputStream -> k
    char[] buffer -> l
    int maxNextCharInd -> m
    int inBuf -> n
    int tabSize -> o
    void ExpandBuff(boolean) -> a
    void FillBuff() -> h
    char BeginToken() -> a
    void UpdateLineColumn(char) -> a
    char readChar() -> b
    int getEndColumn() -> c
    int getEndLine() -> d
    int getBeginColumn() -> e
    int getBeginLine() -> f
    void backup(int) -> a
    void <init>(java.io.Reader,int,int,int) -> <init>
    void <init>(java.io.Reader,int,int) -> <init>
    java.lang.String GetImage() -> g
jugglinglab.notation.ssparser.SiteswapParser -> jugglinglab.c.a.c:
    int jugglers -> b
    int current_juggler -> c
    int current_beat -> d
    int current_beat_sub -> e
    jugglinglab.notation.ssparser.SiteswapParserTokenManager token_source -> f
    jugglinglab.notation.ssparser.SimpleCharStream jj_input_stream -> g
    jugglinglab.notation.ssparser.Token token -> h
    jugglinglab.notation.ssparser.Token jj_nt -> i
    int jj_ntk -> j
    jugglinglab.notation.ssparser.Token jj_scanpos -> k
    jugglinglab.notation.ssparser.Token jj_lastpos -> l
    int jj_la -> m
    int jj_gen -> n
    int[] jj_la1 -> o
    int[] jj_la1_0 -> p
    jugglinglab.notation.ssparser.SiteswapParser$JJCalls[] jj_2_rtns -> q
    boolean jj_rescan -> r
    int jj_gc -> s
    jugglinglab.notation.ssparser.SiteswapParser$LookaheadSuccess jj_ls -> t
    java.util.List jj_expentries -> u
    int[] jj_expentry -> v
    int jj_kind -> w
    int[] jj_lasttokens -> x
    int jj_endpos -> y
    jugglinglab.notation.ssparser.SiteswapTreeItem parsePattern(java.lang.String) -> a
    jugglinglab.notation.ssparser.SiteswapTreeItem Pattern() -> a
    jugglinglab.notation.ssparser.SiteswapTreeItem GroupedPattern() -> b
    jugglinglab.notation.ssparser.SiteswapTreeItem SoloSequence() -> c
    jugglinglab.notation.ssparser.SiteswapTreeItem SoloPairedThrow() -> d
    jugglinglab.notation.ssparser.SiteswapTreeItem SoloMultiThrow() -> e
    jugglinglab.notation.ssparser.SiteswapTreeItem SoloSingleThrow() -> f
    jugglinglab.notation.ssparser.SiteswapTreeItem SoloHandSpecifier() -> g
    jugglinglab.notation.ssparser.SiteswapTreeItem PassingSequence() -> h
    jugglinglab.notation.ssparser.SiteswapTreeItem PassingGroup() -> i
    jugglinglab.notation.ssparser.SiteswapTreeItem PassingThrows() -> j
    jugglinglab.notation.ssparser.SiteswapTreeItem PassingPairedThrow() -> k
    jugglinglab.notation.ssparser.SiteswapTreeItem PassingMultiThrow() -> l
    jugglinglab.notation.ssparser.SiteswapTreeItem PassingSingleThrow() -> m
    jugglinglab.notation.ssparser.SiteswapTreeItem PassingHandSpecifier() -> n
    int Number() -> o
    int Wildcard() -> p
    java.lang.String Modifier() -> q
    boolean jj_2_1(int) -> a
    boolean jj_2_2(int) -> b
    boolean jj_2_3(int) -> c
    boolean jj_3R_84() -> r
    boolean jj_3R_14() -> s
    boolean jj_3_2() -> t
    boolean jj_3R_68() -> u
    boolean jj_3R_79() -> v
    boolean jj_3R_71() -> w
    boolean jj_3R_13() -> x
    boolean jj_3R_70() -> y
    boolean jj_3_1() -> z
    boolean jj_3R_44() -> A
    boolean jj_3R_43() -> B
    boolean jj_3R_42() -> C
    boolean jj_3R_76() -> D
    boolean jj_3R_45() -> E
    boolean jj_3R_41() -> F
    boolean jj_3R_69() -> G
    boolean jj_3R_30() -> H
    boolean jj_3R_28() -> I
    boolean jj_3R_40() -> J
    boolean jj_3R_39() -> K
    boolean jj_3R_35() -> L
    boolean jj_3R_27() -> M
    boolean jj_3R_34() -> N
    boolean jj_3R_24() -> O
    boolean jj_3R_49() -> P
    boolean jj_3R_51() -> Q
    boolean jj_3R_46() -> R
    boolean jj_3R_48() -> S
    boolean jj_3R_50() -> T
    boolean jj_3R_38() -> U
    boolean jj_3R_47() -> V
    boolean jj_3R_33() -> W
    boolean jj_3R_19() -> X
    boolean jj_3R_37() -> Y
    boolean jj_3R_36() -> Z
    boolean jj_3R_32() -> aa
    boolean jj_3R_31() -> ab
    boolean jj_3R_25() -> ac
    boolean jj_3R_16() -> ad
    boolean jj_3R_22() -> ae
    boolean jj_3R_18() -> af
    boolean jj_3R_26() -> ag
    boolean jj_3R_15() -> ah
    boolean jj_3R_23() -> ai
    boolean jj_3R_17() -> aj
    boolean jj_3_3() -> ak
    void <init>(java.io.Reader) -> <init>
    jugglinglab.notation.ssparser.Token jj_consume_token(int) -> d
    boolean jj_scan_token(int) -> e
    int jj_ntk() -> al
    void jj_add_error_token(int,int) -> a
    jugglinglab.notation.ssparser.ParseException generateParseException() -> am
    void jj_rescan_token() -> an
    void jj_save(int,int) -> b
    void <clinit>() -> <clinit>
jugglinglab.notation.ssparser.SiteswapParser$JJCalls -> jugglinglab.c.a.d:
    int gen -> a
    jugglinglab.notation.ssparser.Token first -> b
    int arg -> c
    jugglinglab.notation.ssparser.SiteswapParser$JJCalls next -> d
    void <init>() -> <init>
jugglinglab.notation.ssparser.SiteswapParser$LookaheadSuccess -> jugglinglab.c.a.e:
    void <init>() -> <init>
jugglinglab.notation.ssparser.SiteswapParserConstants -> jugglinglab.c.a.f:
    java.lang.String[] tokenImage -> a
    void <clinit>() -> <clinit>
jugglinglab.notation.ssparser.SiteswapParserTokenManager -> jugglinglab.c.a.g:
    java.lang.String[] jjstrLiteralImages -> b
    long[] jjtoToken -> c
    jugglinglab.notation.ssparser.SimpleCharStream input_stream -> d
    int[] jjrounds -> e
    int[] jjstateSet -> f
    char curChar -> g
    int curLexState -> h
    int jjnewStateCnt -> i
    int jjround -> j
    int jjmatchedPos -> k
    int jjmatchedKind -> l
    int jjStopAtPos(int,int) -> a
    int jjMoveNfa_0(int,int) -> b
    void <init>(jugglinglab.notation.ssparser.SimpleCharStream) -> <init>
    jugglinglab.notation.ssparser.Token jjFillToken() -> b
    jugglinglab.notation.ssparser.Token getNextToken() -> a
    void jjCheckNAdd(int) -> a
    void <clinit>() -> <clinit>
jugglinglab.notation.ssparser.SiteswapTreeItem -> jugglinglab.c.a.h:
    int type -> a
    java.util.ArrayList children -> b
    int jugglers -> c
    int repeats -> d
    boolean switchrepeat -> e
    int beats -> f
    int seq_beatnum -> g
    int source_juggler -> h
    int value -> i
    boolean x -> j
    int dest_juggler -> k
    java.lang.String mod -> l
    boolean spec_left -> m
    int throw_sum -> n
    int beatnum -> o
    boolean left -> p
    boolean vanilla_async -> q
    boolean sync_throw -> r
    jugglinglab.notation.ssparser.SiteswapTreeItem transition -> s
    java.lang.String[] typenames -> t
    int[][] field_defined_types -> u
    void <init>(int) -> <init>
    void addChild(jugglinglab.notation.ssparser.SiteswapTreeItem) -> a
    jugglinglab.notation.ssparser.SiteswapTreeItem getChild(int) -> a
    java.lang.Object clone() -> clone
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> b
    boolean field_active(int,int) -> a
    void <clinit>() -> <clinit>
jugglinglab.notation.ssparser.Token -> jugglinglab.c.a.i:
    int kind -> a
    int beginLine -> b
    int beginColumn -> c
    java.lang.String image -> d
    jugglinglab.notation.ssparser.Token next -> e
    void <init>() -> <init>
    void <init>(int,java.lang.String) -> <init>
    java.lang.String toString() -> toString
    jugglinglab.notation.ssparser.Token newToken(int,java.lang.String) -> a
jugglinglab.notation.ssparser.TokenMgrError -> jugglinglab.c.a.j:
    java.lang.String addEscapes(java.lang.String) -> a
    java.lang.String LexicalError$5e3d1f51(boolean,int,int,java.lang.String,char) -> a
    java.lang.String getMessage() -> getMessage
    void <init>() -> <init>
    void <init>(java.lang.String,int) -> <init>
    void <init>(boolean,int,int,int,java.lang.String,char,int) -> <init>
jugglinglab.path.BouncePath -> jugglinglab.d.a:
    double bx -> e
    double by -> f
    double[] az -> g
    double[] bz -> h
    double[] cz -> i
    double[] endtime -> j
    int bounces -> k
    boolean forced -> l
    boolean hyper -> m
    double bounceplane -> n
    double g -> o
    double bouncefracsqrt -> p
    int numbounces -> q
    void <init>() -> <init>
    void initPath(java.lang.String) -> a
    void calcPath() -> a
    int solveBounceEquation(int,double,double[],boolean[]) -> a
    boolean isFeasibleDuration(double) -> a
    double getMinDuration() -> b
    jugglinglab.util.Coordinate getStartVelocity() -> c
    jugglinglab.util.Coordinate getEndVelocity() -> d
    double evalPolynomial(double[],int,double) -> a
    double bracketOpenInterval(double[],int,double,boolean) -> a
    double findRoot(double[],int,double,double) -> a
    int findRealRootsPolynomial(double[],int,double[]) -> a
jugglinglab.path.Path -> jugglinglab.d.b:
    double start_time -> a
    double end_time -> b
    jugglinglab.util.Coordinate start_coord -> c
    jugglinglab.util.Coordinate end_coord -> d
    void <init>() -> <init>
    jugglinglab.path.Path newPath(java.lang.String) -> b
    void setStart(jugglinglab.util.Coordinate,double) -> a
    void setEnd(jugglinglab.util.Coordinate,double) -> b
    double getDuration() -> e
    double getMinDuration() -> b
    void initPath(java.lang.String) -> a
    void calcPath() -> a
    jugglinglab.util.Coordinate getStartVelocity() -> c
    jugglinglab.util.Coordinate getEndVelocity() -> d
    void <clinit>() -> <clinit>
jugglinglab.path.TossPath -> jugglinglab.d.c:
    double bx -> e
    double by -> f
    double az -> g
    double bz -> h
    void <init>() -> <init>
    void initPath(java.lang.String) -> a
    void calcPath() -> a
    jugglinglab.util.Coordinate getStartVelocity() -> c
    jugglinglab.util.Coordinate getEndVelocity() -> d
jugglinglab.prop.BallProp -> jugglinglab.e.a:
    java.lang.String[] colornames -> a
    alternatives.Color[] colorvals -> b
    void <init>() -> <init>
    void init(java.lang.String) -> a
    void <clinit>() -> <clinit>
jugglinglab.prop.Prop -> jugglinglab.e.b:
    void <init>() -> <init>
    jugglinglab.prop.Prop newProp$5ee43a7c() -> a
    void initProp(java.lang.String) -> b
    void init(java.lang.String) -> a
    void <clinit>() -> <clinit>
jugglinglab.util.Coordinate -> jugglinglab.f.a:
    double x -> a
    double y -> b
    double z -> c
    void <init>() -> <init>
    void <init>(double,double,double) -> <init>
    void <init>(jugglinglab.util.Coordinate) -> <init>
    void setCoordinate(double,double,double) -> a
    double getIndex(int) -> a
    java.lang.String toString() -> toString
jugglinglab.util.JLFunc -> jugglinglab.f.b:
    java.text.NumberFormat nf -> a
    java.lang.String expandRepeats(java.lang.String) -> a
    void addExpansionToBuffer(java.lang.String,java.lang.StringBuffer) -> a
    double parseDouble(java.lang.String) -> b
    java.lang.String toStringRounded(double,int) -> a
jugglinglab.util.JuggleException -> jugglinglab.f.c:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
jugglinglab.util.JuggleExceptionInternal -> jugglinglab.f.d:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
jugglinglab.util.JuggleExceptionUser -> jugglinglab.f.e:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
jugglinglab.util.ParameterList -> jugglinglab.f.f:
    int size -> a
    java.util.ArrayList names -> b
    java.util.ArrayList values -> c
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    boolean addParameter(java.lang.String,java.lang.String) -> a
    java.lang.String getParameter(java.lang.String) -> a
    java.lang.String removeParameter(java.lang.String) -> b
    java.lang.String getParameterName(int) -> a
    java.lang.String getParameterValue(int) -> b
    int getNumberOfParameters() -> a
    java.lang.String toString() -> toString
jugglinglab.util.Permutation -> jugglinglab.f.g:
    int size -> a
    int[] mapping -> b
    boolean reverses -> c
    void <init>(int,boolean) -> <init>
    void <init>(int,int[],boolean) -> <init>
    void <init>(int,java.lang.String,boolean) -> <init>
    java.lang.String toString() -> toString
    java.lang.String toString(boolean) -> a
    java.lang.String convertReverse(int) -> d
    boolean equals(jugglinglab.util.Permutation) -> a
    int getMapping(int) -> a
    int getMapping(int,int) -> a
    jugglinglab.util.Permutation apply(jugglinglab.util.Permutation) -> b
    int getInverseMapping(int) -> e
    jugglinglab.util.Permutation getInverse() -> a
    int lcm(int,int) -> b
    int getOrder() -> b
    int getOrder(int) -> b
    int[] getCycle(int) -> c
